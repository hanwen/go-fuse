{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4430fea4_7e37d9e5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1007981
      },
      "writtenOn": "2025-03-23T21:13:20Z",
      "side": 1,
      "message": "ISSUE: I just noticed that this changes the API, because LoopbackRoot is exported, and Fd is now mandatory.\n\nInternal breakage example: https://review.gerrithub.io/c/hanwen/go-fuse/+/1212014/1\n(it uses Fd \u003d 0, which incidentially does not point to a directory).",
      "revId": "567d54d9242ba872977182054ff71dd8bbff4b39",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74ee005d_00f0bb1f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1007981
      },
      "writtenOn": "2025-03-23T21:19:35Z",
      "side": 1,
      "message": "@hanwenn@gmail.com acceptable or should I rework this to open and close the fd inside each FUSE operation?",
      "parentUuid": "4430fea4_7e37d9e5",
      "revId": "567d54d9242ba872977182054ff71dd8bbff4b39",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a99a356c_0cfd6b42",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-03-24T07:25:04Z",
      "side": 1,
      "message": "could we take fd\u003d\u003d0 to mean to use the old code paths?",
      "parentUuid": "74ee005d_00f0bb1f",
      "revId": "567d54d9242ba872977182054ff71dd8bbff4b39",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "afb59641_2111891b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1007981
      },
      "writtenOn": "2025-03-24T11:45:23Z",
      "side": 1,
      "message": "The wrinkle here is that Fd\u003d0 could be a valid and intended Fd. But I can just document this limitation and how a caller can work around it. Caller will have to open their dir again to get another fd number.",
      "parentUuid": "a99a356c_0cfd6b42",
      "revId": "567d54d9242ba872977182054ff71dd8bbff4b39",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dcddd51b_42482c9c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1007981
      },
      "writtenOn": "2025-03-24T11:49:56Z",
      "side": 1,
      "message": "I could just make it a pointer.\n\nBut keeping two code-paths is gonna be a headache. I think I\u0027ll go with the two-step open like gocryptfs does it:\n\nStep 1: Open basedir, following symlinks\nStep 2: Open path inside, NOT following symlinks",
      "parentUuid": "afb59641_2111891b",
      "revId": "567d54d9242ba872977182054ff71dd8bbff4b39",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a68046d1_ef2afbe7",
        "filename": "fs/loopback.go",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-03-23T12:46:02Z",
      "side": 1,
      "message": "if r.Fd !\u003d -1 ?\n\nwhat about locking. This looks safe , but I bet the race detector thinks otherwise.",
      "revId": "567d54d9242ba872977182054ff71dd8bbff4b39",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b24b707c_2108e044",
        "filename": "fs/loopback.go",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1007981
      },
      "writtenOn": "2025-03-23T19:23:25Z",
      "side": 1,
      "message": "You are right. This is unsafe if OnForget runs concurrently with other FUSE operations. I *think* this can happen when unmounting a filesystem with a lot of activity.\n\nHow about letting the garbage collector figure it out, using runtime.SetFinalizer() on LoopbackRoot?",
      "parentUuid": "a68046d1_ef2afbe7",
      "revId": "567d54d9242ba872977182054ff71dd8bbff4b39",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed6db224_4ea412d0",
        "filename": "fs/loopback.go",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1007981
      },
      "writtenOn": "2025-03-23T21:13:20Z",
      "side": 1,
      "message": "On second though, this would mean sprinkling runtime.KeepAlive() across the code. Let\u0027s not.",
      "parentUuid": "b24b707c_2108e044",
      "revId": "567d54d9242ba872977182054ff71dd8bbff4b39",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0332951_002e51ba",
        "filename": "fs/loopback.go",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-03-24T07:25:04Z",
      "side": 1,
      "message": "the onforget on unmount only runs concurrrently for singlereader\u003dfalse. hwoever, the loopbackroot may also be used as a child of other nodes, and then onforget runs concurrently with other things (but not operations involving the node, b/c the node needs to be alive to have an operation run on it).\n\n\u003e using runtime.SetFinalizer() on LoopbackRoot?\n\nthat may not fix our tests for resource leakage, as GC is non-deterministic.",
      "parentUuid": "ed6db224_4ea412d0",
      "revId": "567d54d9242ba872977182054ff71dd8bbff4b39",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}